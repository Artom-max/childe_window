# Просто зверюшка
# Демонстрирует простейший класс и экзкмпляр
class Pet(object):
    total = 0

    @staticmethod  # декоратор, показывающий что метод будет статическим, а именно будет относитья к классу,
    # а не к объекту, поэтому инициализация с помощью self  не нужна, и они могут вызываться без объектов класса
    def status():
        print('Всего зверюшек сейчас :', Pet.total)

    # создание свойств
    # используются для доступа к закрытым атрибутам(изменению, удаалению или ограничению)
    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, new_name):
        if new_name == '':
            print("имя зверушки не можеты быть пустым")
        else:
            self.__name = new_name
            print("имя изменено")

    # Метод инит будет вызываться автоматически при создании нового экземпляра класса, это называется инициализацией
    # В методах класса первым параметром должен быть всегда параметр Self, для того что бы питон понимал что нужно
    # ссылаться на объект класса
    def __init__(self, name, mood):
        # что бы назначить атрибут метода класса, нужно делать это через Self
        self.__name = name  # self.name = name - открытый атрибут (изменено для показания как работает свойство)
        print("Появилась на свет новая зверюшка! Его зовут: ", self.name)
        Pet.total += 1
        # инкапсуляция(создание закрытых атрибутов или методов), то есть только другие атрибуты или методы этого же
        # объекта будут иметь к ним доступ
        self.__mood = mood  # закрытый атрибут

    def __str__(self):
        # этод метод показывает python как мы ходим описать класс, вместо непонятного битового кода и адреса в памяти
        # мы получим запрограмированное описание
        rep = 'Информация об классе\nОбъект  класаа Pet\n'
        rep += "имя:" + self.name + '\n'
        return rep

    # Функции в классах называются методами
    def talk(self):
        print("привет. я зверюшка, экземпляр класса Pet, меня зовут:", self.name, '\n')
        print("сейчас я чувствую себя", self.__mood, '\n')

    # приватные методы используются другими методами класса
    def __private_method(self):
        print("Это закрытый метод")

    def public_method(self):
        print("это открытй метод")
        self.__private_method() # методы могут использовать приватные методы


# Основная часть
# Созданиие экземляра класса
# Метод вызывается через точку к экземпляру класса
print("получение количества зверушек: ")
Pet.status()
pet = Pet("адольф", mood="УЖАСНО")
pet.talk()
pet1 = Pet("бобик", mood='норм')
pet1.talk()
pet2 = Pet("стив", mood="классно")
# при закрытом атрибуте прямое обращение к нему невозможно:
# print(pet.mood) или print(pet.__mood)
pet2.talk()
print("нынешнее количество зверушек: ", pet1.total)
print("вывод объекта pet  на экран: ")
print(pet)  # бы не метод __str__ прописало бы что то вроеде __main__.Pet object at ОхООАОВА90
print("непосредственный доступ к атрибуду pet.name:")
print(pet.name)
print('однострочный вывод атрибут: ', pet.name)
# для того что бы достучаться до закрытого атрибута, нужно указывать "полный путь"
print(pet._Pet__mood)
pet.public_method()